一、守护线程
public final void setDaemon（Boolean on）:将
什么是守护线程：
坦克大战
攻方
两辆以上
二、通过售票案例，我们发现其售票过程存在很大隐患，（无论是通过继承Thread，还是实现接口后+ticket静态修饰符和）对于线程安全我们该如何解决？
要想解决线程安全问题，就要知道是哪些原因导致出错的？而这些原因也是我们日后判断一个程序是否存在线程安全问题的标准
   A：是否是多线程环境
   B：是否有共享数据
   C: 是否有多条语句操作共享数据
以上三条全部都满足我们问题出现的症状，那么A和B这两条是改变不了的，我们只能对第三条改变
    思考：把多条语句操作共享数据的代码包装成一个整体，让某个线程在执行的时候，别人不能来执行，问题是如何来包装，java提供了一种同步机制
    同步机制
    语法1：
         同步代码块
         synchronized(对象){
                需要同步的代码
         }
         A:对象是什么？
         答：任意类型的对象都可以
         B：需要同步的代码有哪些？
         答：把多条语句操作共享数据的代码的部分给包裹起来
         注意：
              同步可以解决安全问题的根本原因就在那个对象上，该对象如同锁的功能，多个线程必须是同一把锁。
三、同步的特点
        前提是多线程，解决问题的时候要注意多线程必须是使用同一个锁对象
        同步的好处：
            同步的出现解决了多线程的安全问题
        同步的弊端：
            当线程相当多的时候，因为每个线程都会去判断同步上的锁，这个是耗费资源的，无形中也降低了程序的运行效率。（比如银行必须要安全，牺牲一点效率也无所谓）
四、在方法上定义 synchronized 关键字 代表该方法是同步方法（查看jdk,自己看书）
五、死锁
      产生死锁的四个必要条件：
      1.互斥条件，一个资源每次只能被一个进程使用
      2.请求与保持条件：一个进程因请求资源阻塞时，对已获得的资源保持不放
      3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
      4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
      中国人、美国人吃饭的案例
      1.正常情况：
          中国人：筷子一双
          美国人：刀和叉
      现在：中国人：筷子一支，刀一把
            美国人：筷子一支，叉一把

使用wait和notify完成生产者和消费者模式
需要创建产品类Product，定义一个货架，跟产品有关系，货架上货上限，货架上的货物：不是一个，是多个，用集合表示；构造方法：接下来对货架进行初始化
货物也要进行初始化。
货架上上货是有厂家来调用：同一个商品

一、多线程
	1.概述
	2.多线程实现的方案
	3.线程的调度和线程的控制
	4.线程的生命周期
	5.线程同步
	6.线程的死锁
	
二、
	进程：
		正在运行的程序，是系统进行资源分配和调用的独立单位，每一个进程都有它自己的内存空间个系统资源
	
	线程：
		它是进程中单个顺序的控制流，是一条执行路径，如果一个进程只有一条执行路径，则称之为单线程程序。
		一个进程如果有多条执行路径，则称之为多线程程序。  
		
	举例：
		迅雷下载
	
	大家注意两个出现的词汇的区别，并行和并发
		1.前者是逻辑上同时发生，指在某个时间内同时运行多个程序
		2.后者是物理上同时发生，指在某个时间点上同时运行多个程序
			12306

三、Java程序的运行原理：
		首先是由Java命令启动JVM，JVM启动就相当于启动一个进程，接着由该进程创建一个主线程去调用main方法。
		
		思考？
			JVM虚拟机的启动是单线程还是多线程？
			是多线程
			原因是在启动JVM的同时垃圾回收线程也要启动，否则很容易出现内存溢出，现在的垃圾回收线程加上前面的主线程就已经是两个线程了，
			所以JVM的启动就是一个多线程。
			
						
		java在传递引用数据类型时是值传递还是引用传递？
		 是值传递：地址是不可变 值是可以发生改变的				
		
		String 无需要new 它就是一个对象
		String str="abc";
		String str1="abc";
		str==str1
		String str2= new String("abc");
		str==str2
		

四、我们该如何实行多线程的程序？
	由于线程是依赖进程而存在的，所以我们要先创建一个进程出来。而进程是由系统创建的，所以我们应该调用系统功能创建一个进程。
	Java语言是不能直接调用系统功能的，所以我们没有办法直接实现多线程的程序。要由C或C++调用系统功能创建进程，然后由Java去
	调用这样的东西，那么在JDK API中它提供一些类给我们使用，我们才可以实现多线程程序。
	那么这些类是什么呢？
		1.Thread类：通过API可以查看，我们就知道有两种方式去实现多线程。
		
		方法1：
			继承Thread类
				步骤：
					1.自定义一个类继承Thread类
					2.自定义的类中需要重写run方法
					3.创建对象
					4.启动线程
					

		时间轴：统一时间点  当前时间 2018-8-20 14：01：01 线程是讲CPU使用权的
		
		银行
			卡1：ATM1 500
			卡2：ATM2 500
			
			如果在同一个时间点上去取钱   1000 实际余额是500 银行亏损500
			
			网络：等 6秒
			
			49.9元
			
			log
			
			线程安全

五、线程的调度
	假设我们的计算机只有一个CPU，那么CPU在某一个时刻只能执行一条指令，线程只能得到CPU的时间片，也就是刚才所讲的使用权，
	才可以执行指令，那么Java是如何对线程进行调用的呢？
		线程有两种调度方式：
			1.分时调度模型 所有线程轮流使用线程的CPU的使用权，平均分配每个线程所占用的CPU的时间片
			2.抢占式调度模型 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选取一个，优先级高的线程
			获取CPU的时间片会相对多一些。
			
			设置线程优先级：
				public final void setPriority(int newPriority)：更改此线程的优先级。 

六、线程中的各种状态
	1.新建【new】 就是创建一个线程对象
	2.可运行状态【runnable】 线程创建过后，其他线程比如main调用该对象的start方法，该状态的线程位于可运行线程池在中，等待被
	线程调度选中，获取cpu的使用权。
	3.运行【running】，可运行状态的线程获取了cpu的时间片，来执行程序代码
	4.阻塞【block】 阻塞状态是指线程因某种原因放弃了cpu的使用权，即让出cpu的时间片，暂时停止运行，直到线程进入可运行状态，才有机会
	再次获得CPU的时间片转到运行状态，阻塞的状态有三种情况：
		1.等待阻塞 ：运行的线程只要执行  o.wait（）方法，JVM会把该 线程放入等待队列中
		2.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池【lock pool】中
		3.其他阻塞：运行的线程执行sleep（）方法或者join（）方法或者发出I/O请求时，JVM会把该线程设置为阻塞状态，当sleep（）状态
		超时时、或者join等待线程终止或者超时时，或者I/O请求处理完毕时，线程重新转入可运行状态
	5.死亡【dead】线程的run（）或main（）方法执行结束，或者因异常退出了main方法，则该线程结束生命周期，死亡线程不可以再复生。	
		

七、线程创建的第二种写法
		就是实现Runnable接口
		步骤：
			1.书写自定义的类实现Runnable接口
			2.重写run方法
			3.创建Runnable接口对象
			4.使用Thread类的对象，把第3步的对象作为构造参数传入
			
			资源共享： 访问者 多



















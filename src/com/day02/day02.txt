一、守护线程
	public final void setDaemon(boolean on)：将此线程标记为daemon线程或用户线程。 当运行的唯一线程都是守护进程线程时，Java虚拟机将退出。
	
	什么是守护线程
			坦克大战
				攻方
					两辆以上
				守方  
					老家
					两辆坦克


二、通过售票案例 我们发现其售票过程存在很大隐患，对于线程的安全我们该如何解决？
 要想解决线程安全问题，就要知道是哪些原因导致出错的？而这些原因也是我们日后判断一个程序是否存在线程安全问题的标准
 A：是否是多线程环境
 B：是否有共享数据
 C：是否有多条语句操作共享数据
 
 以上三条全部满足我们问题出现的症状，那么A和B这两条是改变不了的，我们只能对第三条改变
 	思考：
 		把多条语句操作共享数据的代码包装成一个整体，让某个线程在执行的时候，别人不能来执行，问题是如何来包装，Java提供了一种
 		同步机制
 		
 		语法1：
 			同步代码块
 				synchronized(对象){
 					需要同步的代码
 				}
			A：对象是什么？
				任意类型的对象都可以
			B：需要同步的代码有哪些？
				把多条语句操作共享数据的代码的部分给包裹起来
			注意：
				同步可以解决安全问题的根本原因就在那个对象上，该对象如同锁的功能，多个线程必须是同一把锁。		

三、同步的特点
	前提是多线程，解决问题的时候要注意多线程必须是使用同一个锁对象
	同步的好处：
		同步的出现解决了多线程中的安全问题
	同步的弊端：
		当线程相当多的时候，因为每个线程都会去判断同步上的锁，这个是耗费资源的，无形中也降低了程序的运行效率。
		
四、在方法上定义	synchronized 关键字 代表该方法是同步方法				

五、死锁
	产生死锁的四个必要条件：
		1.互斥条件，一个资源每次只能被一个进程使用
		2.请求与保持条件：一个进程因请求资源阻塞时，对已获得的资源保持不放
		3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
		4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

	中国人、美国人吃饭的案例
		1.正常情况：
			中国人：筷子一双
			美国人：刀和叉
			
		现在：
			中国人：筷子一支 刀一把
			美国人：筷子一支 叉一把
			
课堂练习：
	定义A、B、C三个售票窗口 同时售票一共50张票
	票需要定义在单独的一个类Ticket中 ，其中属性就是tickets
	使用线程中继承Thread类方式完成售票功能  ，注意Ticket类将被引用到当前 线程类中			
				
使用wait和notify完成生产者和消费者模式

作业：模拟人类上厕所的过程
	使用wait和notify方法完成
	假设过程是如下：
		第1个用户正在使用卫生间，请等待....
		第2个用户请求使用卫生间，要求第1个用户出来
		第1个用户离开卫生间
		第2个用户正在使用卫生间，请等待....
		第3个用户请求使用卫生间，要求第2个用户出来
		第2个用户离开卫生间
		第3个用户离开卫生间

















